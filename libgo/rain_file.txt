Я вот тут подумала. Наверное я фигней занялась, что подключила
гитхабовскую репу для обертки функций бибилиотеки ncurses.
Зачем оборачивать каждую функцию когда можно написать целый блок
и уже пользовательские функции просто засунуть в статическую
библиотеку. Написала из набросков отдельный тестовый сишный файл.
Скомпилила его в статическую библиотеку. Для управления понадобятся
в конечном счете всего 4 функции. прототипы объявления?(сигнатура) которых засунула в отдельный
заголовочный файлик my.h, Все собирается с помощью make. Все получилось
как и было задумано. Api программы на Си, а Вся логика на go.
Думаю перевод срезов в сишные массивы проблемм не вызовет.
cat Makefile
LDFLAGS= -lncursesw
test: test.go my.h libcurs.a
	go build test.go
libsurs.a: curs.o
	ar rcs libcurs.a curs.o
curs.o: curs.c
	gcc -c $< $(LDFLAGS) 

cat test.go
package main

/*
#cgo LDFLAGS: -lncursesw -L. -lcurs
#include "my.h"
*/
import "C"

func main() {
	C.goin()//функция в подключенной библиотеке рисующая фрейм(шаблон).
}

И еще не мало важно, я избавилась от прослойки-посредника.
